<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Redirectingâ€¦</title>
</head>
<body>
<script>
const INWORLD_CSV = "inworld_sites.csv";

function parseCSV(text) {
  const lines = text.trim().split(/\r?\n/);
  const headers = lines.shift().split(",");

  return lines.map(line => {
    const values = [];
    let current = "";
    let inQuotes = false;

    for (const ch of line) {
      if (ch === '"') { inQuotes = !inQuotes; continue; }
      if (ch === "," && !inQuotes) { values.push(current); current = ""; continue; }
      current += ch;
    }
    values.push(current);

    const obj = {};
    headers.forEach((h, i) => obj[h.trim()] = (values[i] || "").trim());
    return obj;
  });
}

async function loadCSV(path) {
  try {
    const res = await fetch(path);
    if (!res.ok) return [];
    const text = await res.text();
    return parseCSV(text);
  } catch {
    return [];
  }
}

function norm(s) {
  return (s || "")
    .trim()
    .toLowerCase()
    .replace(/^https?:\/\//, "")     // strip protocol
    .replace(/\/+$/, "");           // strip trailing slashes
}

function isDomainLike(s) {
  // supports subdomains, but rejects strings with spaces or slashes
  return /^[a-z0-9.-]+\.[a-z]{2,}$/i.test(s);
}

(async function () {
  const rawU = new URLSearchParams(location.search).get("u");
  if (!rawU) { location.href = "index.html"; return; }

  // Keep the raw value too, but compare with a normalised key
  const uNorm = norm(rawU);

  const inworld = await loadCSV(INWORLD_CSV);

  // Build a lookup from multiple identifiers -> canonical internal path
  const lookup = new Map();
  for (const s of inworld) {
    const path = (s.path || "").trim();  // keep original case/slashes for redirect
    if (!path) continue;

    // keys we accept
    const keys = [
      s.id,
      s.path,
      s.display_url,
      s.title
    ];

    for (const k of keys) {
      const key = norm(k);
      if (key) lookup.set(key, path);
    }

    // Also accept path without leading slash (e.g. "biogen")
    lookup.set(norm(path.replace(/^\//, "")), path);
  }

  // 1) In-world resolution (id/path/display_url/title)
  if (lookup.has(uNorm)) {
    location.href = lookup.get(uNorm);
    return;
  }

  // 2) Full URL passed in
  if (/^https?:\/\//i.test(rawU.trim())) {
    location.href = rawU.trim();
    return;
  }

  // 3) Domain-like external
  if (isDomainLike(uNorm)) {
    location.href = "https://" + uNorm;
    return;
  }

  // 4) Fallback
  location.href = "index.html";
})();
</script>
</body>
</html>
