<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Findr Results</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" href="assets/findr-favicon.svg" type="image/svg+xml">
  <link rel="stylesheet" href="style.css">
</head>

<body class="results">

<header class="results-header">
  <img
    src="assets/findr-logo.svg"
    alt="Findr"
    class="results-logo"
    onclick="location.href='index.html'"
  >

  <form class="results-search" action="results.html" method="get">
    <div class="search-shell">
      <input
        type="text"
        name="q"
        id="search"
        class="search-input"
        autocomplete="off"
      >
      <span class="search-icon mic"></span>
      <span class="search-icon scan"></span>
    </div>
  </form>
</header>

<nav class="results-tabs">
  <a class="active">All</a>
  <a>News</a>
  <a>Images</a>
  <a>Maps</a>
</nav>

<main id="results-container"></main>

<script>
/* =========================================================
   CONFIG
========================================================= */

const RESULTS_PER_PAGE = 9;
const NOISE_CSV = "top_sites.csv";
const INWORLD_CSV = "inworld_sites.csv";
const MAX_INWORLD_RESULTS = 2;

/* =========================================================
   HELPERS
========================================================= */

function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}

/* =========================================================
   CSV LOADER (hardened)
========================================================= */

function parseCSV(text) {
  const lines = text.trim().split(/\r?\n/);

  const headers = lines.shift()
    .split(",")
    .map(h =>
      h.replace(/^\uFEFF/, "").trim().toLowerCase()
    );

  return lines.map(line => {
    const values = [];
    let current = "";
    let inQuotes = false;

    for (const ch of line) {
      if (ch === '"') { inQuotes = !inQuotes; continue; }
      if (ch === "," && !inQuotes) {
        values.push(current);
        current = "";
        continue;
      }
      current += ch;
    }
    values.push(current);

    const obj = {};
    headers.forEach((h, i) => {
      obj[h] = (values[i] || "").trim();
    });
    return obj;
  });
}

async function loadCSV(path) {
  try {
    const res = await fetch(path);
    if (!res.ok) return [];
    const text = await res.text();
    return parseCSV(text);
  } catch {
    return [];
  }
}

/* =========================================================
   SEARCH SCORING
========================================================= */

function scoreMatch(query, text) {
  if (!text) return 0;

  const q = query.toLowerCase();
  const t = text.toLowerCase();

  if (t === q) return 100;
  if (t.includes(q)) return 60;

  let score = 0;
  q.split(" ").forEach(word => {
    if (t.includes(word)) score += 15;
  });

  return score;
}

/* =========================================================
   NOISE SEARCH
========================================================= */

function searchNoise(query, sites) {
  return sites
    .map(site => {
      const score =
        scoreMatch(query, site.title) +
        scoreMatch(query, site.domain) +
        scoreMatch(query, site.description) +
        scoreMatch(query, site.keywords);

      return { ...site, score };
    })
    .filter(s => s.score > 0)
    .sort((a, b) => b.score - a.score);
}

/* =========================================================
   IN-WORLD SEARCH (keyword-triggered)
========================================================= */

function searchInWorld(query, sites) {
  const q = query.toLowerCase();

  return sites
    .filter(site => {
      if (!site.keywords) return false;
      return site.keywords
        .toLowerCase()
        .split(",")
        .some(k => q.includes(k.trim()));
    })
    .map(site => ({
      ...site,
      score: scoreMatch(query, site.keywords)
    }))
    .sort((a, b) => b.score - a.score);
}

/* =========================================================
   RENDERING
========================================================= */

function renderResult({ title, url, snippet, href }) {
  return `
    <div class="result">
      <a class="result-title" href="${href}">${title}</a>
      <div class="result-url">${url}</div>
      <p class="snippet">${snippet}</p>
    </div>
  `;
}

/* =========================================================
   MAIN SEARCH
========================================================= */

async function runFindr() {
  const params = new URLSearchParams(location.search);
  const query = params.get("q") || "";
  document.getElementById("search").value = query;

  if (!query) return;

  const [noiseSites, inworldSites] = await Promise.all([
    loadCSV(NOISE_CSV),
    loadCSV(INWORLD_CSV)
  ]);

  const inworldMatches = searchInWorld(query, inworldSites);
  const noiseMatches = searchNoise(query, noiseSites);

  const results = [];

  /* =====================================================
     TIER 1 — IN-WORLD RESULTS (IF ANY TRIGGER)
  ===================================================== */

  if (inworldMatches.length > 0) {
    inworldMatches.slice(0, MAX_INWORLD_RESULTS).forEach(site => {
      results.push({
        title: site.title,
        url: site.display_url || site.path,
        snippet:
          site.description && site.description.length
            ? site.description
            : `Information about ${site.title}.`,
        href: `go.html?u=${site.path}`
      });
    });
  }

  /* =====================================================
     TIER 2 — NOISE RESULTS
  ===================================================== */

  const usedDomains = new Set(results.map(r => r.url));

  noiseMatches.forEach(site => {
    if (results.length >= RESULTS_PER_PAGE) return;
    if (usedDomains.has(site.domain)) return;

    results.push({
      title: site.title,
      url: site.domain,
      snippet: site.description || `Information from ${site.title}.`,
      href: `go.html?u=${site.domain}`
    });
  });

  /* =====================================================
     FILLER — RANDOM NOISE
  ===================================================== */

  const filler = shuffle(
    noiseSites.filter(s => !usedDomains.has(s.domain))
  );

  while (results.length < RESULTS_PER_PAGE && filler.length) {
    const site = filler.shift();
    results.push({
      title: site.title,
      url: site.domain,
      snippet: site.description || `Information from ${site.title}.`,
      href: `go.html?u=${site.domain}`
    });
  }

  document.getElementById("results-container").innerHTML =
    results.map(renderResult).join("");
}

runFindr();
</script>

</body>
</html>
