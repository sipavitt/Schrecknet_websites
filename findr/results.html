<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Findr Results</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" href="assets/findr-favicon.svg" type="image/svg+xml">
  <link rel="stylesheet" href="style.css">
</head>

<body class="results">

<!-- Header -->
<header class="results-header">
  <img
    src="assets/findr-logo.svg"
    alt="Findr"
    class="results-logo"
    onclick="location.href='index.html'"
  >

  <form class="results-search" action="results.html" method="get">
    <div class="search-shell">
      <input
        type="text"
        name="q"
        id="search"
        class="search-input"
        autocomplete="off"
      >
      <span class="search-icon mic"></span>
      <span class="search-icon scan"></span>
    </div>
  </form>
</header>

<!-- Tabs -->
<nav class="results-tabs">
  <a class="active">All</a>
  <a>News</a>
  <a>Images</a>
  <a>Maps</a>
</nav>

<!-- Results -->
<main id="results-container"></main>

<script>
/* =========================================================
   CONFIG
========================================================= */

const RESULTS_PER_PAGE = 9;
const NOISE_CSV = "top_sites.csv";
const INWORLD_CSV = "inworld_sites.csv";

/* =========================================================
   HELPERS
========================================================= */

function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}

/* =========================================================
   CSV LOADER (safe for commas + quotes)
========================================================= */

function parseCSV(text) {
  const lines = text.trim().split(/\r?\n/);

  const headers = lines.shift()
    .split(",")
    .map(h =>
      h
        .replace(/^\uFEFF/, "") // remove BOM if present
        .trim()
        .toLowerCase()
    );

  return lines.map(line => {
    const values = [];
    let current = "";
    let inQuotes = false;

    for (const ch of line) {
      if (ch === '"') { inQuotes = !inQuotes; continue; }
      if (ch === "," && !inQuotes) { values.push(current); current = ""; continue; }
      current += ch;
    }
    values.push(current);

    const obj = {};
    headers.forEach((h, i) => {
      obj[h] = (values[i] || "").trim();
    });
    return obj;
  });
}

async function loadCSV(path) {
  try {
    const res = await fetch(path);
    if (!res.ok) return [];
    const text = await res.text();
    return parseCSV(text);
  } catch {
    return [];
  }
}

/* =========================================================
   SEARCH SCORING
========================================================= */

function scoreMatch(query, text) {
  const q = query.toLowerCase();
  const t = text.toLowerCase();

  if (t === q) return 100;
  if (t.includes(q)) return 60;

  let score = 0;
  q.split(" ").forEach(word => {
    if (t.includes(word)) score += 15;
  });

  return score;
}

/* =========================================================
   NOISE SEARCH (top_sites.csv)
========================================================= */

function searchNoise(query, sites) {
  return sites
    .map(site => {
      const score =
        scoreMatch(query, site.title) +
        scoreMatch(query, site.domain) +
        scoreMatch(query, site.description || "") +
        scoreMatch(query, site.keywords || "");


      return { ...site, score };
    })
    .filter(s => s.score > 0)
    .sort((a, b) => b.score - a.score);
}

/* =========================================================
   IN-WORLD SEARCH (keyword-gated)
========================================================= */

function searchInWorld(query, sites) {
  const q = query.toLowerCase();

  return sites.filter(site => {
    if (!site.keywords) return false;
    return site.keywords
      .toLowerCase()
      .split(",")
      .some(k => q.includes(k.trim()));
  });
}

/* =========================================================
   RENDERING
========================================================= */

function renderResult({ title, url, snippet, href }) {
  return `
    <div class="result">
      <a class="result-title" href="${href}">${title}</a>
      <div class="result-url">${url}</div>
      <p class="snippet">${snippet}</p>
    </div>
  `;
}

/* =========================================================
   MAIN SEARCH EXECUTION
========================================================= */

async function runFindr() {
  const params = new URLSearchParams(location.search);
  const query = params.get("q") || "";
  document.getElementById("search").value = query;

  if (!query) return;

  const [noiseSites, inworldSites] = await Promise.all([
    loadCSV(NOISE_CSV),
    loadCSV(INWORLD_CSV)
  ]);

  const noiseMatches = searchNoise(query, noiseSites);
  const inworldMatches = searchInWorld(query, inworldSites);

  const results = [];

  /* 1. Relevant noise first */
  noiseMatches.forEach(site => {
    if (results.length < RESULTS_PER_PAGE) {
      results.push({
        title: site.title,
        url: site.domain,
        snippet: site.description || `Information from ${site.title}.`,
        href: `go.html?u=${site.domain}`
      });
    }
  });

  /* 2. Inject in-world results naturally */
  inworldMatches.forEach(site => {
    if (results.length < RESULTS_PER_PAGE) {
      results.splice(
        Math.min(2, results.length),
        0,
        {
          title: site.title,
          url: site.display_url || site.path,
          snippet:
            site.description && site.description.length
              ? site.description
              : `Information about ${site.title}.`,
          href: `go.html?u=${site.path}`
        }
      );
    }
  });

  /* 3. Randomised filler noise */
  const usedDomains = new Set(results.map(r => r.url));
  const fillerNoise = shuffle(
    noiseSites.filter(s => !usedDomains.has(s.domain))
  );

  while (results.length < RESULTS_PER_PAGE && fillerNoise.length) {
    const site = fillerNoise.shift();
    results.push({
      title: site.title,
      url: site.domain,
      snippet: site.description || `Information from ${site.title}.`,
      href: `go.html?u=${site.domain}`
    });
  }

  /* Render */
  document.getElementById("results-container").innerHTML =
    results.map(renderResult).join("");
}

runFindr();
</script>

</body>
</html>


